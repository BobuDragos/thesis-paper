

  
  \[
    \text{Directory } D := \{d_1, d_2, \ldots, d_n\}, \quad \text{where } \text{TypeOf}(d_i) \in \{\text{File}, \text{Directory}\}
  \]
  
  \[
    \forall \ module_i \in \text{frontend} \Rightarrow 
    module_i \supseteq \{\text{init.py}, \text{main.py}, \text{cli.py}\}
  \]
  
  Specific to this implementation, we have the following modules and sub-modules:
  
  \[
    (\exists \ \text{Editor} \in \text{Modules}). \ \text{Editor.submodules} \
    \rightarrow_{\text{depend on}} \ \text{PyQt}
  \]
  
  \[
    (\exists \ \text{Editor} \in \text{Modules}). \ \text{Editor.submodules} \
    \supseteq \{\text{Hierarchy}, \text{Scene View}, \text{Inspector}, \text{Assets}, \text{Terminal}\}
  \]
  
  \[
    (\exists \ \text{Assets} \in \text{Editor.submodules}). \ \text{Assets} \rightarrow_{\text{modifies}} \{\text{Project Tree}\} 
  \]
  
  \[
    (\exists \ \text{Hierarchy} \in \text{Editor.submodules}). \ \text{Hierarchy} \rightarrow_{\text{modifies}} \ \text{JSON\_Scene\_File}
  \]
  
  \[
    (\exists \ \text{Inspector} \in \text{Editor.submodules}). \ \text{Inspector} \rightarrow_{\text{modifies}} \ \text{JSON\_Scene\_File}
  \]
  
  The interactions between different modules can be represented using functions and mappings. Let \( f: E \to H \) represent the function mapping elements from the Editor to the Hub. 
  Similarly, \( g: H \to S_p \) represents the mapping from Hub to Splash.
  
  \[
  \begin{aligned}
    \text{user} &\xrightarrow{\text{launch}} \text{splash}     
         \xrightarrow{\text{launch}} \text{Hub}          
         \xrightarrow{\text{launch}} \text{Editor} \\
  \end{aligned}
  \]
 
  \[
  \begin{aligned}
        \text{Editor}  &\xrightarrow{\text{launch}} \{\text{Hierarchy}, \text{SceneView}, \text{Inspector}, \text{Assets}\}
  \end{aligned}
  \]

  \[
  \text{SceneView} \xrightarrow{\text{launch}} (\text{c++ } \land \text{python}) \ \text{Runner} \xrightarrow{\text{launch}} \{\text{opengl}, \text{scipy}\}
  \]
  
  \[
  \text{Hierarchy} \xrightarrow{\text{reads}} \{\text{active\_scene.json}\}
  \]
  
  \[
  \text{Inspector} \xrightarrow{\text{reads}} \{\text{active\_game\_object.json}\}
  \]
  
  \[
  \text{Assets} \xrightarrow{\text{reads}} \{\text{FileTreeOf(projectPath)}\}
  \]
  
  \[
  (\text{user} \land \text{Hub}) \lor (\text{user} \land \text{Editor}) \lor (\text{user} \land \text{CLInterface}) \xrightarrow{\text{Request}} (\text{FileManager} \lor \text{SceneManager})
  \xrightarrow{\text{response}}
  \]
  







  \pagebreak

\section*{Submodule Communication}

In the game engine, submodules within the frontend communicate using well-defined processes to ensure a coherent and synchronized user experience. Each submodule is designed to handle specific tasks, and they interact with each other through a series of function calls, events, and data sharing mechanisms.

\subsection*{Communication Mechanisms}

\begin{itemize}
    \item \textbf{Function Calls:} Direct function calls are used when a submodule needs to invoke a specific operation in another submodule. For example, the Scene View might call functions in the Inspector to update the properties of a selected object.
    \item \textbf{Event System:} An event-driven architecture allows submodules to subscribe to and broadcast events. When an event occurs (e.g., a user selects an object in the Hierarchy), an event is broadcasted to all interested submodules (e.g., Scene View and Inspector).
    \item \textbf{Shared Data Structures:} Submodules often share data structures, such as the JSON scene file. When one submodule modifies this data (e.g., the Hierarchy reorders objects), the changes are reflected across all submodules that read from the same data.
\end{itemize}

\subsection*{Example Workflow}

Consider a scenario where the user selects a game object in the Hierarchy, and this selection needs to be reflected in the Scene View and Inspector:

\begin{enumerate}
    \item \textbf{Hierarchy:} The user clicks on an object in the Hierarchy submodule.
    \item \textbf{Event Broadcast:} The Hierarchy submodule broadcasts a "selection changed" event.
    \item \textbf{Scene View:} The Scene View submodule receives the event and highlights the selected object.
    \item \textbf{Inspector:} The Inspector submodule receives the event and displays the properties of the selected object for editing.
\end{enumerate}

\subsection*{Inter-Process Communication (IPC)}

For more complex interactions, especially those that might involve asynchronous operations or different processes, Inter-Process Communication (IPC) mechanisms are used:

\begin{itemize}
    \item \textbf{Message Passing:} Submodules send messages to each other to request actions or share information. This can be implemented using various IPC methods such as sockets, message queues, or shared memory.
    \item \textbf{Remote Procedure Calls (RPC):} One submodule can invoke functions in another submodule as if they were local, even though they might be running in separate processes. This abstraction simplifies communication and coordination.
\end{itemize}

% \subsection*{Synchronization}

% To maintain data consistency and avoid race conditions, synchronization mechanisms such as locks, semaphores, and mutexes are employed. These ensure that only one submodule can modify shared data at a time, preserving the integrity of the data.

% \subsection*{Summary}

% The communication between frontend submodules in the game engine is a blend of direct function calls, event-driven updates, shared data structures, and IPC mechanisms. This robust communication framework allows for a highly interactive and responsive user interface, where changes in one submodule are promptly reflected across all relevant parts of the application.













  % \[
  % \xrightarrow{\text{request}} (\text{FileManager} \lor \text{SceneManager})
  % \xrightarrow{\text{response}}
  % \]
  % 

% \begin{quote}
% The frontend component is organized 
% into several directories and files. 

% It includes functionalities for 
% the editor, hub, and splash interfaces. 
% \end{quote}


% \begin{math}
%   Directory \ D \ :=  \{d_1, d_2, \ldots, d_n\}
%   , 
%   where \ \ \TypeOf (\( d_i \)) \in \{File, Directory\}
% \end{math}


% \begin{math}
%   \forall module_i \in frontend \Rightarrow 
%   module_i 
%   \supseteq
%   \{init.py, main.py, cli.py\}
% \end{math}

% Specific to this implementation, 
% we have the following modules and sub-modules:


% \begin{math}
%   (\exists \ Editor \in Modules).
%   Editor.submodules \
%   \rightarrow_{depend\ on} PyQt
% \end{math}

% \begin{math}
%   (\exists \ Editor \in Modules).
%   Editor.submodules \
%   \supseteq \{ Hierarchy, Scene \ View, Inspector, Assets, Terminal \}
% \end{math}


% \begin{math}
%   (\exists \ Assets \in Editor.submodules).
%   \ Assets \rightarrow_{modifies} \{ \ Project \ Tree \} 
% \end{math}

% \begin{math}
%   (\exists \ Hierarchy \in Editor.submodules).
%   \ Hierarchy \rightarrow_{modifies} \ JSON\_Scene\_File
% \end{math}

% \begin{math}
%   (\exists \ Inspector \in Editor.submodules).
%   \ Inspector \rightarrow_{modifies} JSON\_Scene\_File\ 
% \end{math}

% % \begin{math}
% %   (\exists \ Terminal \in Editor.submodules).
% %   \ Terminal = Terminal
% % \end{math}



% The interactions between different modules can be represented using functions and mappings.
% Let \( f: E \to H \) represent the function mapping elements from the Editor to the Hub.
% Similarly, \( g: H \to S_p \) represents the mapping from Hub to Splash.


% \begin{math}

%   user \xrightarrow{launch} splash     
%        \xrightarrow{launch} Hub          
%        \xrightarrow{launch} Editor
%        \xrightarrow{launch} \{Hierarchy, SceneView, Inspector, Assets \}

%   SceneView \xrightarrow{launch} (\text{c++ } \land python ) \  Runner \xrightarrow{launch} \{ opengl, matplotlib, numpy \}

%   Hierarchy \xrightarrow{reads} \{ active_scene.json \}
  
%   Inspector \xrightarrow{reads} \{ active_game_object.json \}
  
%   Assets    \xrightarrow{reads} \{ FileTreeOf(projectPath) \}

%   (user \land Hub ) \lor (user \land Editor) \lor (user \land CLInterface) \xrightarrow{Request} (FileManager \lor SceneManager)

%   \xrightarrow{request} (FileManager \lor SceneManager)
%         \xrightarrow{response} 

%   %      \rightarrow_{request} FileManager \rightarrow_{response} Editor \rightarrow_{reaction} user

%   % user \rightarrow splash     \rightarrow_{action} Hub  \rightarrow_{request} FileManager \rightarrow_{response} Hub \rightarrow_[reaction] user

%   % user \rightarrow_{request} Hub.CLI    \rightarrow_{request} FileManager 

%   % user \rightarrow_{request} Editor.CLI \rightarrow_{request} FileManager 

%   % user \rightarrow_{request} FileManager 
% \end{math}





